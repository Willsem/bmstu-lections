\chapter{Проектирование программных компонентов}

\section{Программные структуры среднего уровня. Принципы SOLID}

\subsection{Уровни проектирования}

\begin{itemize}
    \item Уровень функций и методов
    \item Уровень классов
    \item Уровень организации компонентов
    \item Архитектурный уровень
\end{itemize}

\subsection{Программный компонент}

\textbf{Программный компонент} --
единица развертывания ({\ttfamily .jar, .gem, .dll})

\textbf{Программный компонент} --
программная часть системы компонент программного обеспечения

\begin{itemize}
    \item Независимое развертывание
    \item Независимая разработка
\end{itemize}

\subsection{Программный компонент}

\subsubsection{Из чего состоит?}

Состоит из хорошо спроектированных программных структур среднего уровня

\subsubsection{Как создать хорошую программную
структуру среднего уровня?}

\subsection{SOLID}

\begin{itemize}
    \item \textbf{SRP}: Single Responsibility Principle
        (Принцип единственной отвественности)
    \item \textbf{OCP}: Open-Closed Principle
        (Принцип открытости/закрытости)
    \item \textbf{LSP}: Liskov Substitution Principle
        (Принцип подстановки Барбары Лисков)
    \item \textbf{ISP}: Interface Sgregation Principle
        (Принцип разделения интерфейсов)
    \item \textbf{DIP}: Dependency Inversion Principle
        (Принцип инверсии зависимостей)
\end{itemize}

\subsubsection{SRP. Принцип единственной ответственности}

\begin{itemize}
    \item Модуль должен отвечать за одного и только одного
        актора (внешняя роль)
    \item Модуль должен иметь одну и только одну причину для
        изменения
\end{itemize}

Несоблюдение:

\begin{itemize}
    \item Проблема модификации общих частей
    \item Проблема слияния изменений
\end{itemize}

\subsubsection{OCP. Принцип открытости/закрытости}

\begin{itemize}
    \item Программные сущности должны быть открыты для расширения
        и закрыты для изменения
    \item Цель: легкая расширяемость и безопасность от влияния
        изменений
\end{itemize}

Упорядочивание в иерархию, защищающую компоненты уровнем выше
от изменения в компонентах уровня ниже

Чем выше политики -- тем выше защита

\subsubsection{LSP. Принцип подстановки Барбары Лисков}

\begin{itemize}
    \item Если для каждого объекта о1 типа S существует такой
        объект о2 типа T, что для всех программ P, определенных
        в терминах T, поведение P не изменяется при подстановке о1
        вместо о2, то S является подтипом T.
    \item Простое нарушение совместимости может вызвать \textbf{
        загрязнение} архитектуры системы \textbf{значительным
    количеством дополнительных механизмов}
\end{itemize}

Проблема квадрат-прямоугольник (квадрат не может поддерживать логику
прямоугольника)

\subsubsection{ISP. Принцип разделения интерфейсов}

\begin{itemize}
    \item Зависимости, несущие лишний груз ненужных и неиспользуемых
        особенностей, могут стать причиной неожиданных проблем.
\end{itemize}

\subsubsection{DIP. Принцип инверсии зависимости}

Для максимальной гибкости:

Зависимости должны быть направлены на абстракции, а не конкретные
реализации

\subsection{Инверсия управления}

\textbf{IoC} -- архитектурное решение интеграции, упрощающее расширение
возможностей системы, при котором поток управления программы
контролируется фреймворком.

Логика:

\begin{itemize}
    \item логика взаимодействия программы разбросана
    \item поток управления задан неявно
\end{itemize}

\subsection{Dependency Injection}

\begin{itemize}
    \item Внедрение зависимости -- процесс предоставления внешней
        зависимости программному компоненту
    \item В соответствии с SRP объект отдает заботу о построении
        требуемых ему зависимостей внешнему общему механизму
\end{itemize}

\subsection{Лабораторная работа 1}

\begin{enumerate}
    \item Use-Case -- диаграмма курсового
    \item ER-диаграмма сущностей (не путать с БД)
    \item Технологический стек
    \item UML диаграммы классов для двух отдельных компонентов из
        курсового -- компонента доступа к данным и компонента с
        бизнес-логикой
    \item Программная реализация компонента доступа к данным
\end{enumerate}

\section{Принципы организации компонентов}

\subsection{История}

\begin{itemize}
    \item Неперемещаемые библиотеки
    \item Перемещаемые библиотеки (связывающий загрузчик)
    \item Компоновщик (редактор связи) + загрузчик
\end{itemize}

Любая программа растет, пока не заполнит все доступное время на
компиляцию и компоновку

\subsection{Компоненты}

\textbf{Программные компоненты} -- динамически связываемые файлы,
которые можно подключать во время выполнения (связывающий загрузчик).

\subsection{Свяязность компонентов}

\subsubsection{Принцип эквивалентности повторного использования
и выпусков (REP)}

<<Выпуск>>:

\begin{itemize}
    \item Номер версии
    \item Описание новой версии
    \item Change Log (Лог изменений)
\end{itemize}

Единица повторного использования -- Единица выпуска

Классы и модули, объединяемые в компонент, должны выпускаться вместе

Объединение в один выпуск должно иметь \textbf{смысл}
для автора и пользователей.

\subsubsection{Принцип согласованного изменения (CPP)}

Развитие принципов <<единственной ответственности>> (SRP) и
<<открытости/закрытости>> из SOLID

\begin{itemize}
    \item В один компонент должны включаться классы, изменяющиеся по
        одним причинам и в одно время
    \item В разные компоненты должны включаться классы, изменяющиеся
        по разным причинам и в разное время
\end{itemize}

\subsubsection{Принцип совместного и повторного использования (CRP)}

Для \textbf{большинства} приложений простота сопровождения
\textbf{важнее} возможности повторного использования.

Идея: Объединение в компонент классов, закрытых для одного и того же
вида изменений.

Изменение требований $\Rightarrow$ изменение \textbf{МИНИМАЛЬНОГО}
количества компонентов

\begin{itemize}
    \item Не вынуждаете пользователей компонента зависеть от
        того, что им не требуется
    \item Классы, не имеющие тесной связи, не должны включаться
        в компонент
\end{itemize}

\subsection{Баланс}

\begin{itemize}
    \item Много ненужных выпусков
    \item Изменения затрагивают много компонентов
    \item Проблемы с повторным использованием
\end{itemize}

\subsection{Сочетаемость компонентов}

\begin{itemize}
    \item Принцип ацикличности зависимостей
    \item Принцип устойчивых зависимостей
    \item Принцип устойчивости абстракций
\end{itemize}

\subsubsection{Принцип ацикличности зависимостей (ADP)}

Циклы в графе зависимостей недопустимы

Отдельные компоненты -- отдельные разработчики/команды

Появление цикла -- появление БОЛЬШОГО копмпонента

Разрыв цикла:

\begin{itemize}
    \item Применить принцип DIP
    \item Создать новый компонент, от которого зависят проблемные
\end{itemize}

\subsection{Проектирование сверху вниз?}

\begin{itemize}
    \item Граф зависимостей формируется для защиты стабильных и ценных
        компонентов от влияния изменчивых компонентов
    \item Структура компонентов отражает удобство сборки сопровождения
\end{itemize}

\textit{Поэтому она не проектируется полностью в начале разработки}

\subsection{Принцип устойчивых зависимостей}

Зависимости должны быть направлены в сторону устойчивости

\begin{equation*}
    \text{Метрика неустойчивости} =
    \frac{\text{выходы}}{\text{входы + выходы}}
\end{equation*}

Метрика неустойчивости компонента должна быть выше метрик неустойчивости
компонентов, от которых он зависит.

\subsection{Принцип устойчивости абстракций}

Устойчивости компонента пропорциональна его абстракции

Пример: Компоненты, содержащие только интерфейсы в C\# и Java.
